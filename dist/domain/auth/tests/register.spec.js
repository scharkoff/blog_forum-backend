"use strict";var _bcrypt=_interopRequireDefault(require("bcrypt")),_User=_interopRequireDefault(require("../../user/entity/User.js")),_authService=_interopRequireDefault(require("../auth.service.js")),_tokenService=_interopRequireDefault(require("../../token/token.service.js"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const authService=new _authService.default;jest.mock("bcrypt"),describe("Register module",()=>{let a,b,c,d,e;beforeEach(()=>{a={body:{email:"test@example.com",fullName:"Test User",password:"123456"}},b={status:jest.fn().mockReturnThis(),json:jest.fn()},d={_id:"mockUserId",rank:"user",email:a.body.email,fullName:a.body.fullName,avatarUrl:"mockUserAvatarUrl",passwordHash:"mockPasswordHash"},c={...d,_doc:d},e="mockToken"}),afterEach(()=>{jest.clearAllMocks()}),it("Should register new user with token",async()=>{jest.spyOn(_User.default,"findOne").mockResolvedValue(null),jest.fn("save").mockResolvedValue(c),_User.default.prototype.save=jest.fn().mockResolvedValue(c),_bcrypt.default.genSalt.mockResolvedValueOnce("mockSalt"),_bcrypt.default.hash.mockResolvedValueOnce("mockPasswordHash"),_tokenService.default.prototype.generateTokens=jest.fn().mockResolvedValue(e),await authService.register(a,b),expect(_bcrypt.default.genSalt).toHaveBeenCalledWith(10),expect(_bcrypt.default.hash).toHaveBeenCalledWith(a.body.password,"mockSalt"),expect(_tokenService.default.prototype.generateTokens).toHaveBeenCalledWith({id:c._id}),expect(b.status).toHaveBeenCalledWith(200);const{passwordHash:d,...f}=c._doc;expect(b.json).toHaveBeenCalledWith({userData:f,token:e})}),it("Should return error if the email is already in use",async()=>{jest.spyOn(_User.default,"findOne").mockResolvedValue("Some user data"),await authService.register(a,b),expect(b.status).toHaveBeenCalledWith(400),expect(b.json).toHaveBeenCalledWith({message:"\u0414\u0430\u043D\u043D\u0430\u044F \u043F\u043E\u0447\u0442\u0430 \u0443\u0436\u0435 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F"})})});